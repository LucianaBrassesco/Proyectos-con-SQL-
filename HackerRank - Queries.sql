-- SQL ADVANCED SELECT - "Type of Triangle"
SELECT 
    CASE
        WHEN ((A+B) <= C) OR ((A+C) <= B) OR ((B+C) <= A) THEN 'Not A Triangle'
        WHEN (A = B) AND (B = C)  AND (A = C) THEN 'Equilateral'
        WHEN (A = B) OR (A = C) OR (B = C) THEN  'Isosceles'
        WHEN (A <> B) AND (A <> C) AND (C <> B) THEN 'Scalene'
    END
FROM 
    TRIANGLES

-- SQL BASIC JOIN - "Challenges"
WITH CHL AS (
    SELECT 
        HACKER_ID
        , COUNT(CHALLENGE_ID) AS CANT
    FROM
        CHALLENGES
    GROUP BY 
        HACKER_ID),
RP_CHL AS (
    SELECT 
        HACKER_ID
        , CANT
        , COUNT(CANT) OVER (PARTITION BY CANT) AS NUM_REP
    FROM CHL)
SELECT 
    HK.HACKER_ID
    , HK.NAME
    , RPCHL.CANT
FROM 
    HACKERS HK
FULL JOIN RP_CHL RPCHL ON HK.HACKER_ID = RPCHL.HACKER_ID
WHERE 
    RPCHL.CANT = (SELECT MAX(CANT) FROM RP_CHL) OR 
    RPCHL.NUM_REP = 1
ORDER BY 
    RPCHL.CANT DESC
    , HK.HACKER_ID 

-- SQL BASIC JOIN - "Contest Leaderboard"
WITH LISTA_HK AS (
    SELECT 
        HACKER_ID
        , CHALLENGE_ID
        , MAX(SCORE) AS NOTAS
    FROM 
        SUBMISSIONS
    GROUP BY
        HACKER_ID
        , CHALLENGE_ID), 
SC_SUM AS (
    SELECT 
        HACKER_ID
        , SUM(NOTAS) AS MAX_NOTAS
    FROM 
        LISTA_HK
    GROUP BY 
        HACKER_ID)
        
SELECT 
    HK.HACKER_ID
    , HK.NAME
    , SC.MAX_NOTAS
FROM 
    HACKERS HK
FULL JOIN SC_SUM SC ON HK.HACKER_ID = SC.HACKER_ID
WHERE 
    SC.MAX_NOTAS > 0
ORDER BY
    SC.MAX_NOTAS DESC, 
    HK.HACKER_ID

-- SQL ALTERNATIVE QUERIES - 'Draw The Triangle 1'
/* (Nota: este me gustaría repetirlo pero con un Stored Procedure y que el número a imprimir lo pueda introducir el usuario, del estilo
de una función en Python)
*/
DECLARE @CONTADOR INT;
SET @CONTADOR = 22; -- le puse 22 porque me dibujaba dos estrellas menos (no entendí bien porqué)

WHILE 
    @CONTADOR > 0
    IF @CONTADOR > 1
        BEGIN
        PRINT REPLICATE('* ', @CONTADOR)
        SET @CONTADOR = @CONTADOR - 1
        END
    ELSE 
        BEGIN
        PRINT '*'
        SET @CONTADOR = @CONTADOR - 1
        END

-- SQL ALTERNATIVE QUERIES - 'Draw The Triangle 2'
/* (Nota: es el mismo ejercicio de antes, pero dibuja el triángulo al revés)
*/
DECLARE @CONTADOR INT;
SET @CONTADOR = -1; 

WHILE 
    @CONTADOR <= 20
    IF @CONTADOR < 20
        BEGIN
        PRINT REPLICATE('* ', @CONTADOR)
        SET @CONTADOR = @CONTADOR + 1
        END
    ELSE 
        BEGIN
        PRINT REPLICATE('* ', 20)
        SET @CONTADOR = @CONTADOR + 1
        END

-- SQL BASIC JOIN - "The Report"
WITH NOTAS AS (
    SELECT
        ST.ID
        , ST.NAME
        , ST.MARKS
        , GR.GRADE
    FROM 
        STUDENTS ST
    INNER JOIN GRADES GR ON ST.MARKS <= GR.MAX_MARK AND ST.MARKS >= GR.MIN_MARK)

SELECT 
    (CASE
        WHEN GRADE >= 8 THEN NAME
        ELSE NULL
    END)
    , GRADE
    , MARKS
FROM 
    NOTAS
ORDER BY
    GRADE DESC
    , NAME 



-- SQL BASIC JOIN - 'Top Competitors'
WITH SCORES AS (
    SELECT 
        SBT.HACKER_ID [HCK_ID]
        , SBT.CHALLENGE_ID [ CHL_ID]
        , SBT.SCORE [HCK_SCORES]
        , CHLT.DIFFICULTY_LEVEL [DIF_LEVEL]
FROM SUBMISSIONS SBT
INNER JOIN CHALLENGES CHLT ON SBT.CHALLENGE_ID = CHLT.CHALLENGE_ID), 
FINAL_SCORES AS (
    SELECT 
        SCORES.HCK_ID
        , SCORES.HCK_SCORES
        , SCORES.DIF_LEVEL
        , DFT.SCORE 
        , (CASE
           WHEN SCORES.HCK_SCORES = DFT.SCORE THEN 1
           ELSE 0
          END) AS [RESULT]
FROM SCORES 
INNER JOIN DIFFICULTY DFT ON SCORES.DIF_LEVEL = DFT.DIFFICULTY_LEVEL), 
RESULTADOS AS (
    SELECT 
        HCK_ID
        , SUM(RESULT) AS TOTAL_GANADOS
FROM FINAL_SCORES
GROUP BY HCK_ID)

SELECT 
    RESULTADOS.HCK_ID
    , HACKERS.NAME
FROM RESULTADOS
INNER JOIN HACKERS ON RESULTADOS.HCK_ID = HACKERS.HACKER_ID
WHERE 
    RESULTADOS.TOTAL_GANADOS > 1
ORDER BY
    RESULTADOS.TOTAL_GANADOS DESC
    , RESULTADOS.HCK_ID

-- SQL BASIC JOIN - "Ollivander's Inventory"

WITH VARITAS AS (
    SELECT WNS.ID
        , WNSP.AGE
        , WNS.COINS_NEEDED
        , WNS.POWER 
        , WNSP.IS_EVIL
        , ROW_NUMBER() OVER (PARTITION BY WNS.CODE, WNS.POWER  ORDER BY WNS.COINS_NEEDED) AS ROW_NUM 
    FROM 
        WANDS WNS
    INNER JOIN WANDS_PROPERTY WNSP ON WNS.CODE = WNSP.CODE)
    
SELECT
    ID
    , AGE
    , COINS_NEEDED
    , POWER
FROM 
    VARITAS
WHERE 
    ROW_NUM = 1 AND IS_EVIL = 0
ORDER BY
    POWER DESC
    , AGE DESC


-- SQL ADVANCED JOIN - 'SQL Project Planning'
WITH INICIO AS (
    -- FECHA DE INICIO Y NUM DEL PROYECTOS (NUM_1)
    SELECT START_DATE
            , ROW_NUMBER() OVER(ORDER BY START_DATE) AS NUM_1
    FROM PROJECTS
    WHERE START_DATE NOT IN (SELECT END_DATE FROM PROJECTS)), 
FIN AS (
    -- FECHA DE FIN Y NUM DEL PROYECTO (NUM_2)
    SELECT END_DATE
            , ROW_NUMBER() OVER(ORDER BY START_DATE) AS NUM_2
    FROM PROJECTS
    WHERE END_DATE NOT IN (SELECT START_DATE FROM PROJECTS))


/* INICIO -> SI LA FECHA DE INICIO NO ESTÁ EN LA COLUMNA DE FECHAS DE FINALIZACIÓN, ENTONCES
ES PORQUE SE TRATA DE LA PRIMERA ACTIV. DEL PROYECTO. 
EL NÚMERO DE FECHAS DE INICIO ES EQUIVALENTE A CONTAR LA CANTIDAD DE PROYECTOS.  */  
    
/* FIN -> SI LA FECHA DE FIN NO ESTÁ EN LA COLUMNA DE FECHAS DE COMIENZO, ENTONCES ES PORQUE 
SE TRATA DE LA ÚLTIMA ACTIV. DEL PROYECTO. 
EL NÚMERO DE ACTIVIDADES DE FIN ES EQUIVALENTE AL NÚMERO DE PROYECTOS. */

SELECT INICIO.START_DATE
        , FIN.END_DATE
FROM 
    INICIO 
    FULL JOIN FIN ON INICIO.NUM_1 = FIN.NUM_2
ORDER BY 
    DATEDIFF(DAY, INICIO.START_DATE, FIN.END_DATE)
    , INICIO.START_DATE



--SQL ADVANCED JOIN - "Placements"
	WITH TABLA AS (
    SELECT 
        ST.ID AS IDENTIFICACION
        , ST.NAME AS NOMBRE
        , PCK.SALARY AS SUELDO
        , FR.FRIEND_ID AS BFF
        , (SELECT SALARY FROM PACKAGES WHERE ID = FR.FRIEND_ID) AS BFF_SUELDO
    FROM 
        STUDENTS ST
    FULL JOIN PACKAGES PCK ON ST.ID = PCK.ID
    FULL JOIN FRIENDS FR ON ST.ID = FR.ID)

SELECT 
    NOMBRE
FROM 
    TABLA
WHERE 
    SUELDO < BFF_SUELDO
ORDER BY
    BFF_SUELDO

-- SQL ADVANCED JOIN - "Symmetric Pairs"
SELECT X
        , Y
FROM 
    FUNCTIONS
WHERE 
    X = Y 
GROUP BY X, Y
HAVING 
    COUNT(*) > 1
UNION ALL
SELECT *
FROM   
    FUNCTIONS
WHERE 
    CONCAT('(', Y, ',', X, ')') IN (SELECT CONCAT('(', X, ',', Y, ')') FROM FUNCTIONS)
    AND X < Y
ORDER BY 
        X



-- SQL ADVANCED JOIN - "Interviews"
WITH SB_STATS AS (
SELECT 
    CHAL.COLLEGE_ID
    , SUM(SB.TOTAL_SUBMISSIONS) AS [TOTAL_SUB]
    , SUM(SB.TOTAL_ACCEPTED_SUBMISSIONS) AS [TOTAL_ACC_SUB]
FROM 
    CHALLENGES CHAL
    INNER JOIN SUBMISSION_STATS SB ON CHAL.CHALLENGE_ID = SB.CHALLENGE_ID    
GROUP BY 
    CHAL.COLLEGE_ID),
SV_STATS AS (
SELECT 
    CHAL.COLLEGE_ID
    , SUM(VW.TOTAL_VIEWS) AS [TOTAL_VW]
    , SUM(VW.TOTAL_UNIQUE_VIEWS) AS [TOTAL_UNIQUE_VW]
FROM 
    CHALLENGES CHAL
    INNER JOIN VIEW_STATS VW ON CHAL.CHALLENGE_ID = VW.CHALLENGE_ID
GROUP BY 
    CHAL.COLLEGE_ID),
TT_STATS AS (
    SELECT
        SB.COLLEGE_ID
        , SB.TOTAL_SUB
        , SB.TOTAL_ACC_SUB
        , VW.TOTAL_VW
        , VW.TOTAL_UNIQUE_VW
    FROM 
    SB_STATS SB
    JOIN SV_STATS VW ON SB.COLLEGE_ID = VW.COLLEGE_ID)
    
SELECT 
    CNT.CONTEST_ID
    , CNT.HACKER_ID
    , CNT.NAME
    , SUM(ST.TOTAL_SUB)
    , SUM(ST.TOTAL_ACC_SUB)
    , SUM(ST.TOTAL_VW)
    , SUM(ST.TOTAL_UNIQUE_VW)
FROM CONTESTS CNT
JOIN COLLEGES CLS ON CNT.CONTEST_ID = CLS.CONTEST_ID
JOIN TT_STATS ST ON CLS.COLLEGE_ID = ST.COLLEGE_ID
GROUP BY CNT.CONTEST_ID, CNT.HACKER_ID, CNT.NAME
HAVING SUM(ST.TOTAL_SUB) + SUM(ST.TOTAL_ACC_SUB) + SUM(ST.TOTAL_VW) + SUM(ST.TOTAL_UNIQUE_VW) > 0
ORDER BY CNT.CONTEST_ID 


--
WITH SUB AS (
    SELECT SUBMISSION_DATE
        , COUNT(*) AS SUB_PER_DATE
    FROM 
        SUBMISSIONS
    GROUP BY
            SUBMISSION_DATE)


--- SQL ADVANCED JOIN - "15 Days of Learning SQL"

-- START DATE 03/01/2016 
-- END DATE 03/15/2016

-- LISTA DE TODOS LOS HACKERS QUE REALIZARON 1 ENTREGA POR DÍA (COMENZANDO EN LA START DATE)
-- LISTA DE LOS HACKERS QUE HICIERON LA MAYOR CANTIDAD DE ENTREGAS POR DÍA. SI MÁS DE UN HACKER HIZO LA MÁXIMA CANTIDAD DE ENTREGA, ENTONCES DEVOLVER EL QUE TIENE EL MENOR HACKER_ID


-- Esta tabla devuelve un ranking de acuerdo al día (cada día se lo identifica por un número), 
-- y devuelve un acumulado de ENTREGAS de cada hacker (acumulativo).
WITH TABLA_SUB AS (
    SELECT 
        SUBMISSION_DATE
        , SUBMISSION_ID
        , HACKER_ID
        , SCORE
        , DENSE_RANK() OVER (ORDER BY SUBMISSION_DATE) AS DATE_RANK
        , DENSE_RANK() OVER (PARTITION BY HACKER_ID ORDER BY SUBMISSION_DATE) AS HCK_RANK
    FROM 
        SUBMISSIONS
    WHERE 
        SUBMISSION_DATE >= '2016-03-01' AND 
        SUBMISSION_DATE <= '2016-03-15'), 
-- Esta tabla devuelve el número total de Hackers que enviaron, por lo menos una vez, una entrega, en cada día. 
ENTREGAS_TOTAL_DIA AS (
    SELECT 
        SUBMISSION_DATE
        , COUNT(DISTINCT HACKER_ID) AS HCK_CUENTA_DIA
    FROM TABLA_SUB 
    WHERE 
        DATE_RANK = HCK_RANK
    GROUP BY
        SUBMISSION_DATE
        ),
-- Esta tabla devuelve el número de entregas que realizó cada Hacker en cada día. 
ENTREGAS_HCK_DIA AS (
    SELECT 
        SUBMISSION_DATE
        , HACKER_ID
        , COUNT(HACKER_ID) AS HCK_SUB
    FROM SUBMISSIONS
    GROUP BY 
        SUBMISSION_DATE
        , HACKER_ID),
-- Esta tabla devuelve el número máximo de entregas que se realizaron hasta ese día.
MAX_ENTREGAS_DIA AS(
    SELECT 
        SUBMISSION_DATE
        , MAX(HCK_SUB) AS MAX_SUB
    FROM ENTREGAS_HCK_DIA
    GROUP BY
        SUBMISSION_DATE),
-- Esta tabla devuelve una lista de Hackers que realizaron la mayor cantidad de entregas hasta ese día, pero ordenados de acuerdo a su 
-- Hacker_ID
INFO_HCK_MAX AS (
    SELECT 
        ENTREGAS_HCK_DIA.SUBMISSION_DATE
        , ENTREGAS_HCK_DIA.HACKER_ID
        , ENTREGAS_HCK_DIA.HCK_SUB
        , ROW_NUMBER() OVER(PARTITION BY ENTREGAS_HCK_DIA.SUBMISSION_DATE ORDER BY ENTREGAS_HCK_DIA.HACKER_ID) AS RANGO_HCK
    FROM ENTREGAS_HCK_DIA
    INNER JOIN MAX_ENTREGAS_DIA ON ENTREGAS_HCK_DIA.SUBMISSION_DATE = MAX_ENTREGAS_DIA.SUBMISSION_DATE AND ENTREGAS_HCK_DIA.HCK_SUB = MAX_ENTREGAS_DIA.MAX_SUB), 
--- Esta tabla devuelve una lista de Hackers que realizaron la mayor cantidad de entregas hasta ese día, pero solos que tienen < Hacker ID
TABLA_FINAL AS (
    SELECT
        INFO_HCK_MAX.SUBMISSION_DATE
        , ENTREGAS_TOTAL_DIA.HCK_CUENTA_DIA
        , INFO_HCK_MAX.HACKER_ID
        , HACKERS.NAME
    FROM INFO_HCK_MAX 
    INNER JOIN ENTREGAS_TOTAL_DIA ON INFO_HCK_MAX.SUBMISSION_DATE = ENTREGAS_TOTAL_DIA.SUBMISSION_DATE
    INNER JOIN HACKERS ON INFO_HCK_MAX.HACKER_ID = HACKERS.HACKER_ID
    WHERE INFO_HCK_MAX.RANGO_HCK = 1)

SELECT *
FROM 
    TABLA_FINAL
ORDER BY 
    SUBMISSION_DATE

--- SQL ADVANCED JOIN - "Print Prime Numbers"
DECLARE @NUMERO AS INT
DECLARE @LISTA AS VARCHAR(2000)

SET @NUMERO = 3
SET @LISTA = '2'

WHILE (@NUMERO <= 1000)
BEGIN
DECLARE @CONTADOR AS INT
DECLARE @PRIMO AS INT
SET @CONTADOR = 2
SET @PRIMO = 1
        WHILE (@CONTADOR < @NUMERO)
        BEGIN
            IF (@NUMERO%@CONTADOR) = 0 
            BEGIN
                SET @PRIMO = 0
            END
        SET @CONTADOR = @CONTADOR + 1
        END
        IF @PRIMO = 1 
        BEGIN
            SET @LISTA = @LISTA + '&' + CAST(@NUMERO AS VARCHAR(MAX))
        END
        SET @NUMERO = @NUMERO + 1
END
SELECT @LISTA